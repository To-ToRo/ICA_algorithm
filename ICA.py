from numpy.lib.npyio import genfromtxt
import seaborn as sns
from matplotlib import pyplot as plt
from scipy.io import wavfile
from scipy import signal
import numpy as np
from numpy.core.fromnumeric import mean
np.random.seed(0)
sns.set(rc={'figure.figsize': (11.7, 8.27)})


def g(x):
    return np.tanh(x)


def g_der(x):
    return 1 - g(x) * g(x)


def center(X):
    X = np.array(X)
    mean = X.mean(axis=1, keepdims=True)
    return X - mean


def bubble_sort(array, U):
    n = len(array)
    for i in range(n - 1):
        for j in range(n - i - 1):
            if array[j] > array[j + 1]:
                array[j], array[j + 1] = array[j + 1], array[j]
                for k in range(n):
                    U[k][j], U[k][j + 1] = U[k][j + 1], U[k][j]


def whitening(X):
    cov = np.cov(X)

    U = 1

    for i in range(1, 16):
        a1 = np.array([cov[0][0], cov[1][0], cov[2][0], cov[3][0]])
        a2 = np.array([cov[0][1], cov[1][1], cov[2][1], cov[3][1]])
        a3 = np.array([cov[0][2], cov[1][2], cov[2][2], cov[3][2]])
        a4 = np.array([cov[0][3], cov[1][3], cov[2][3], cov[3][3]])

        u1 = a1
        u2 = a2 - ((u1[0]*a2[0] + u1[1]*a2[1] + u1[2]*a2[2] + u1[3]
                   * a2[3])/(u1[0]**2 + u1[1]**2 + u1[2]**2 + u1[3]**2))*u1
        u3 = a3 - ((u1[0]*a3[0] + u1[1]*a3[1] + u1[2]*a3[2] + u1[3]*a3[3])/(u1[0]**2 + u1[1]**2 + u1[2]**2 + u1[3]**2))*u1 \
            - ((u2[0]*a3[0] + u2[1]*a3[1] + u2[2]*a3[2] + u2[3]*a3[3]) /
               (u2[0]**2 + u2[1]**2 + u2[2]**2 + u2[3]**2))*u2
        u4 = a4 - ((u1[0]*a4[0] + u1[1]*a4[1] + u1[2]*a4[2] + u1[3]*a4[3])/(u1[0]**2 + u1[1]**2 + u1[2]**2 + u1[3]**2))*u1 \
            - ((u2[0]*a4[0] + u2[1]*a4[1] + u2[2]*a4[2] + u2[3]*a4[3])/(u2[0]**2 + u2[1]**2 + u2[2]**2 + u2[3]**2))*u2 \
            - ((u3[0]*a4[0] + u3[1]*a4[1] + u3[2]*a4[2] + u3[3]*a4[3]) /
                (u3[0]**2 + u3[1]**2 + u3[2]**2 + u3[3]**2))*u3

        e1 = u1 / ((u1[0]**2 + u1[1]**2 + u1[2]**2 + u1[3]**2)**0.5)
        e2 = u2 / ((u2[0]**2 + u2[1]**2 + u2[2]**2 + u2[3]**2)**0.5)
        e3 = u3 / ((u3[0]**2 + u3[1]**2 + u3[2]**2 + u3[3]**2)**0.5)
        e4 = u4 / ((u4[0]**2 + u4[1]**2 + u4[2]**2 + u4[3]**2)**0.5)

        Q = np.c_[e1, e2, e3, e4]
        R = np.array([
            [a1[0]*e1[0] + a1[1]*e1[1] + a1[2]*e1[2] + a1[3]*e1[3], a2[0]*e1[0] + a2[1]*e1[1] + a2[2]*e1[2] + a2[3]*e1[3],
                a3[0]*e1[0] + a3[1]*e1[1] + a3[2]*e1[2] + a3[3]*e1[3], a4[0]*e1[0] + a4[1]*e1[1] + a4[2]*e1[2] + a4[3]*e1[3]],
            [0, a2[0]*e2[0] + a2[1]*e2[1] + a2[2]*e2[2] + a2[3]*e2[3], a3[0]*e2[0] + a3[1]*e2[1] +
                a3[2]*e2[2] + a3[3]*e2[3], a4[0]*e2[0] + a4[1]*e2[1] + a4[2]*e2[2] + a4[3]*e2[3]],
            [0, 0, a3[0]*e3[0] + a3[1]*e3[1] + a3[2]*e3[2] + a3[3]*e3[3],
                a4[0]*e3[0] + a4[1]*e3[1] + a4[2]*e3[2] + a4[3]*e3[3]],
            [0, 0, 0, a4[0]*e4[0] + a4[1]*e4[1] + a4[2]*e4[2] + a4[3]*e4[3]]])

        cov = np.dot(R, Q)
        U = np.dot(U, Q)

    # 정렬
    array = [R[0][0], R[1][1], R[2][2], R[3][3]]
    bubble_sort(array, U)

    R = np.array([
        [array[0], 0, 0, 0],
        [0, array[1], 0, 0],
        [0, 0, array[2], 0],
        [0, 0, 0, array[3]]])

    E = U
    D = R

    D_inv_sqrt = np.sqrt(np.linalg.inv(D))
    V = np.dot(D_inv_sqrt, E.T)
    Z = np.dot(V, X)

    X_whiten = np.dot(D_inv_sqrt, np.dot(E.T, X))
    return X_whiten


def calculate_new_w(w, X):
    zmean = np.zeros((4), dtype=X.dtype)
    for i in range(128):
        zTw = np.zeros((4, 4), dtype=X.dtype)
        for j in range(4):
            for k in range(4):
                zTw[j][k] = w[j] * X[k][i]  # 행렬곱 (4*1) x (1*4)

        # zTw2 = np.zeros((4, 4), dtype=X.dtype)
        # zTw3 = np.zeros((4, 4), dtype=X.dtype)
        # for j in range(4):
        #     for k in range(4):
        #         for p in range(4):
        #             zTw2[j][k] += zTw[j][p] * zTw[p][k]
        # for j in range(4):
        #     for k in range(4):
        #         for p in range(4):
        #             zTw3[j][k] += zTw2[j][p] * zTw[p][k]
        # print(zTw3)

        # print(np.matmul(np.matmul(zTw, zTw), zTw))
        # break

        # break
        # for j in range(4):
        #     for k in range(4):
        #         zmean[j] += (X[:, i][k] *
        #                      np.matmul(np.matmul(zTw, zTw), zTw)[k][j])
        # print(zmean[j])

        zmean += np.matmul(X[:, i], np.matmul(zTw, np.matmul(zTw, zTw)))
        # print(zmean)
        # break
    zmean /= 128
    # print(zmean)
    w_new = zmean - 3 * w
    return w_new


# 논문 알고리즘 적용
def symm_orth(W):
    W = (3/2 * W) - (1/2 * np.matmul(np.matmul(W, W.T), W))
    return W


def norm_calc(W):
    W[0] /= np.sqrt((W[0] ** 2).sum())
    W[1] /= np.sqrt((W[1] ** 2).sum())
    W[2] /= np.sqrt((W[2] ** 2).sum())
    W[3] /= np.sqrt((W[3] ** 2).sum())

    # W /= np.abs(W[:,0]).sum()
    # W /= np.sqrt((W[:, 1] ** 2)).sum()
    return W


def ica(X, iterations, tolerance=1e-5):
    X = center(X)
    X = whitening(X)
    components_nr = X.shape[0]

    W = np.zeros((components_nr, components_nr), dtype=X.dtype)
    W_new = np.zeros((components_nr, components_nr), dtype=X.dtype)
    W_ica = np.zeros((components_nr, components_nr), dtype=X.dtype)

    # Generate random W (initial value)
    # np.random.seed(1)
    # for i in range(components_nr):
    # W[i] = np.random.rand(components_nr)
    W[0][0] = -0.1493
    W[0][1] = -0.5911
    W[0][2] = 0.37934
    W[0][3] = -0.1747
    W[1][0] = 2.449
    W[1][1] = -0.6547
    W[1][2] = -0.3303
    W[1][3] = -0.9573
    W[2][0] = 0.473
    W[2][1] = -1.0807
    W[2][2] = -0.4999
    W[2][3] = 1.2925
    W[3][0] = 0.1169
    W[3][1] = -0.0477
    W[3][2] = -0.0359
    W[3][3] = 0.4409
    #################################

    for i in range(iterations):
        # Symmetric Orthogonalization
        W[0] /= np.sqrt((W[0] ** 2).sum())
        W[1] /= np.sqrt((W[1] ** 2).sum())
        W[2] /= np.sqrt((W[2] ** 2).sum())
        W[3] /= np.sqrt((W[3] ** 2).sum())

        while(1):
            # W = (3/2 * W) - (1/2 * np.dot(np.dot(W, W.T), W))
            W = symm_orth(W)
            orth_test = np.abs((np.matmul(W.T, W) - np.identity(n=4))).sum()
            # print(orth_test)
            if orth_test < 0.0001:
                break
        ##############################

        # NORM Divider Block
        W = norm_calc(W)    # W /= W.sum()
        ##########################

        # one-unit fast ica module
        W_new[0] = calculate_new_w(W[0], X)
        # break
        W_new[1] = calculate_new_w(W[1], X)
        W_new[2] = calculate_new_w(W[2], X)
        W_new[3] = calculate_new_w(W[3], X)
        ############################
        # 베릴로그 여기까지 완성
        # print(W * pow(2, 13))

        # Error calculation module
        distance = np.abs(np.abs(W_new) - np.abs(W_ica)).sum()

        W_ica = W_new.copy()
        W = W_new.copy()

        if distance < tolerance:
            print("ITERATIONS:")
            print(i+1)
            # print("DISTSANCE:")
            # print(distance)
            # print("W")
            # print(W)
            break
        #############################

    S = np.dot(W, X)
    return S


def plot_mixture_sources_predictions(X, original_sources, S):
    fig = plt.figure()
    plt.subplot(3, 1, 1)
    for x in X:
        plt.plot(x)
    plt.title("mixtures")
    plt.subplot(3, 1, 2)
    for s in original_sources:
        plt.plot(s)
    plt.title("real sources")
    plt.subplot(3, 1, 3)
    for s in S:
        plt.plot(s)
    plt.title("predicted sources")

    fig.tight_layout()
    plt.show()


n_samples = 128
time = np.linspace(0, 8, n_samples)
s1 = np.sin(2 * time)  # sinusoidal
s2 = np.sign(np.sin(3 * time))  # square signal
s3 = signal.sawtooth(2 * np.pi * time)  # saw tooth signal
s4 = np.random.rand(128)

X = np.c_[s1, s2, s3, s4]
A = np.array(([[1, 1, 1, 1], [2.1, 0.5, 2, 1.0], [
             0.8, 1.5, 1.0, 2.0], [2, 3, 1.2, 4.1]]))
X = np.dot(X, A.T)
# X = np.array([
#     [2393.987100, 13788.757000, 11915.185000, 28640.871000],
#     [2395.209500, 13789.658000, 11920.087000, 28644.729000],
#     [2382.631600, 13784.777000, 11919.743000, 28643.352000],
#     [2365.179200, 13772.634000, 11912.213000, 28632.779000],
#     [2358.542000, 13769.447000, 11911.670000, 28631.982000],
#     [2353.002900, 13768.940000, 11913.628000, 28631.254000],
#     [2358.575000, 13775.494000, 11918.698000, 28636.148000],
#     [2366.760300, 13776.498000, 11910.731000, 28633.514000],
#     [2371.623800, 13768.278000, 11894.387000, 28623.328000],
#     [2377.929000, 13770.295000, 11893.590000, 28625.443000],
#     [2372.167200, 13770.094000, 11896.966000, 28627.006000],
#     [2368.087200, 13771.715000, 11906.687000, 28632.650000],
#     [2363.273700, 13772.738000, 11911.255000, 28635.387000],
#     [2349.821000, 13766.751000, 11908.938000, 28631.299000],
#     [2343.520800, 13763.001000, 11906.290000, 28625.684000],
#     [2352.794900, 13767.932000, 11903.258000, 28625.900000],
#     [2377.826400, 13780.921000, 11906.823000, 28635.201000],
#     [2392.467500, 13786.382000, 11906.838000, 28640.475000],
#     [2381.180200, 13776.266000, 11895.880000, 28631.250000],
#     [2365.029100, 13770.896000, 11893.382000, 28625.404000],
#     [2356.476300, 13768.638000, 11896.060000, 28621.807000],
#     [2347.931600, 13764.490000, 11893.239000, 28615.178000],
#     [2342.591100, 13766.491000, 11895.728000, 28618.184000],
#     [2347.262700, 13769.683000, 11895.084000, 28620.369000],
#     [2358.812300, 13769.730000, 11886.808000, 28616.496000],
#     [2372.472200, 13771.491000, 11878.748000, 28616.027000],
#     [2374.224600, 13773.925000, 11878.839000, 28617.561000],
#     [2366.326200, 13772.833000, 11881.958000, 28616.975000],
#     [2355.454800, 13772.125000, 11886.109000, 28616.449000],
#     [2345.694300, 13770.671000, 11886.802000, 28614.910000],
#     [2339.780500, 13771.417000, 11887.034000, 28614.826000],
#     [2346.080600, 13774.986000, 11889.530000, 28617.256000],
#     [2361.888200, 13779.419000, 11888.659000, 28621.906000],
#     [2379.659900, 13783.135000, 11885.176000, 28626.098000],
#     [2382.306200, 13782.788000, 11887.908000, 28629.035000],
#     [2375.149400, 13783.397000, 11894.477000, 28632.654000],
#     [2369.586400, 13785.496000, 11902.516000, 28635.313000],
#     [2367.635500, 13789.900000, 11909.240000, 28634.814000],
#     [2366.518800, 13795.261000, 11913.572000, 28636.055000],
#     [2363.865500, 13792.403000, 11913.157000, 28634.002000],
#     [2371.922400, 13792.299000, 11912.413000, 28635.654000],
#     [2379.682400, 13784.545000, 11899.441000, 28628.555000],
#     [2381.309300, 13776.419000, 11887.384000, 28621.170000],
#     [2378.542700, 13776.498000, 11889.421000, 28620.689000],
#     [2369.859900, 13775.668000, 11892.899000, 28619.941000],
#     [2360.110400, 13775.199000, 11896.072000, 28622.207000],
#     [2354.285400, 13774.407000, 11897.903000, 28621.572000],
#     [2350.418200, 13776.100000, 11897.445000, 28620.143000],
#     [2355.506600, 13777.997000, 11898.348000, 28623.195000],
#     [2368.955800, 13780.330000, 11895.196000, 28624.254000],
#     [2378.944100, 13781.215000, 11889.081000, 28621.002000],
#     [2383.016100, 13788.522000, 11894.578000, 28627.955000],
#     [2371.715300, 13786.861000, 11893.101000, 28627.236000],
#     [2356.318800, 13775.886000, 11887.304000, 28616.600000],
#     [2355.004200, 13777.322000, 11893.831000, 28619.482000],
#     [2350.240700, 13778.355000, 11898.916000, 28621.719000],
#     [2347.515600, 13775.396000, 11895.894000, 28617.422000],
#     [2361.683800, 13781.250000, 11895.729000, 28619.926000],
#     [2379.248000, 13784.239000, 11890.404000, 28621.033000],
#     [2381.012500, 13780.672000, 11885.797000, 28620.420000],
#     [2374.678200, 13781.503000, 11890.736000, 28622.203000],
#     [2374.190200, 13787.649000, 11905.664000, 28632.986000],
#     [2376.014400, 13794.605000, 11918.963000, 28643.900000],
#     [2363.871100, 13786.860000, 11916.833000, 28637.162000],
#     [2357.115000, 13780.814000, 11912.801000, 28632.277000],
#     [2364.039100, 13780.457000, 11911.125000, 28632.639000],
#     [2376.199000, 13776.808000, 11902.878000, 28630.564000],
#     [2385.808300, 13778.005000, 11899.884000, 28633.068000],
#     [2384.835200, 13778.370000, 11903.293000, 28635.029000],
#     [2375.747100, 13776.685000, 11907.348000, 28634.594000],
#     [2367.036900, 13775.856000, 11911.893000, 28634.592000],
#     [2366.603800, 13779.541000, 11920.027000, 28639.477000],
#     [2364.888700, 13781.860000, 11923.772000, 28642.133000],
#     [2367.177000, 13782.561000, 11918.786000, 28640.363000],
#     [2374.211900, 13780.050000, 11906.552000, 28634.271000],
#     [2379.917700, 13775.229000, 11890.950000, 28624.541000],
#     [2375.472700, 13770.938000, 11884.489000, 28618.633000],
#     [2369.569600, 13773.078000, 11889.834000, 28622.361000],
#     [2367.341600, 13778.984000, 11901.485000, 28631.049000],
#     [2355.762900, 13775.204000, 11900.493000, 28626.248000],
#     [2347.293900, 13771.358000, 11898.794000, 28624.184000],
#     [2345.744100, 13768.427000, 11895.614000, 28622.432000],
#     [2350.980500, 13765.278000, 11882.916000, 28612.354000],
#     [2366.531300, 13768.133000, 11876.181000, 28611.846000],
#     [2372.020000, 13771.477000, 11877.477000, 28616.158000],
#     [2368.071500, 13775.820000, 11882.424000, 28618.699000],
#     [2358.445800, 13775.619000, 11884.619000, 28616.531000],
#     [2355.492900, 13777.779000, 11888.481000, 28618.564000],
#     [2348.908000, 13780.204000, 11893.358000, 28619.416000],
#     [2340.054400, 13773.538000, 11887.347000, 28610.828000],
#     [2346.892800, 13773.852000, 11886.459000, 28612.367000],
#     [2363.642300, 13777.853000, 11883.207000, 28616.559000],
#     [2367.655800, 13773.709000, 11873.173000, 28609.547000],
#     [2364.701700, 13773.804000, 11873.736000, 28610.174000],
#     [2358.791700, 13776.588000, 11881.787000, 28615.107000],
#     [2344.345700, 13767.944000, 11879.695000, 28609.250000],
#     [2340.016800, 13770.061000, 11884.806000, 28612.289000],
#     [2344.400100, 13779.617000, 11897.656000, 28621.682000],
#     [2350.867700, 13780.355000, 11897.516000, 28623.943000],
#     [2358.166500, 13777.198000, 11888.620000, 28619.598000],
#     [2365.252700, 13774.021000, 11876.229000, 28612.355000],
#     [2360.741500, 13769.181000, 11871.035000, 28608.525000],
#     [2347.856400, 13763.746000, 11868.728000, 28604.207000],
#     [2345.501200, 13766.866000, 11877.331000, 28607.117000],
#     [2345.939500, 13767.589000, 11883.531000, 28612.162000],
#     [2338.145500, 13763.471000, 11882.324000, 28608.912000],
#     [2340.802200, 13764.665000, 11882.120000, 28607.730000],
#     [2357.450000, 13771.932000, 11884.267000, 28615.621000],
#     [2376.436300, 13779.814000, 11885.249000, 28621.727000],
#     [2378.755600, 13781.386000, 11883.243000, 28622.223000],
#     [2372.753700, 13779.979000, 11886.640000, 28624.064000],
#     [2366.757100, 13778.574000, 11893.159000, 28625.453000],
#     [2365.476100, 13781.363000, 11902.844000, 28630.688000],
#     [2359.452600, 13782.345000, 11906.715000, 28631.746000],
#     [2350.810100, 13776.070000, 11900.820000, 28625.783000],
#     [2354.805400, 13774.193000, 11896.498000, 28622.639000],
#     [2370.715300, 13773.895000, 11890.784000, 28620.148000],
#     [2385.780800, 13774.240000, 11889.985000, 28622.566000],
#     [2389.866500, 13780.975000, 11898.441000, 28630.123000],
#     [2381.535600, 13780.601000, 11903.353000, 28633.590000],
#     [2371.942600, 13780.289000, 11905.630000, 28635.473000],
#     [2367.222700, 13782.773000, 11911.866000, 28639.010000],
#     [2373.783700, 13790.845000, 11923.922000, 28649.244000],
#     [2379.341800, 13791.960000, 11918.933000, 28649.023000],
#     [2382.043200, 13778.653000, 11899.520000, 28634.561000],
#     [2387.286400, 13768.416000, 11884.737000, 28627.205000],
#     [2379.915300, 13762.869000, 11879.569000, 28623.461000],
#     [2375.750000, 13767.063000, 11888.200000, 28626.123000]
# ])

X = X.T


S = ica(X, iterations=700)
plot_mixture_sources_predictions(X, [s1, s2, s3, s4], S)
